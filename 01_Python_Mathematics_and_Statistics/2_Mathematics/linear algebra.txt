# ğŸ“ piro_linear_algebra_complete.py
"""
Piro AI - Complete Linear Algebra Library
Piro AI - Tam Lineer Cebir KÃ¼tÃ¼phanesi

Kapsanan Konular / Covered Topics:
1. VektÃ¶rler / Vectors
2. Matrisler / Matrices  
3. Determinant ve Ters / Determinant and Inverse
4. Ã–zdeÄŸer ve Ã–zvektÃ¶rler / Eigenvalues and Eigenvectors
5. Lineer Denklem Sistemleri / Linear Equation Systems
6. Matris AyrÄ±ÅŸtÄ±rmalarÄ± / Matrix Decompositions
7. VektÃ¶r UzaylarÄ± / Vector Spaces
8. Matris NormlarÄ± / Matrix Norms
9. Ä°leri Uygulamalar / Advanced Applications
"""

import numpy as np
import scipy.linalg
from typing import Union, Tuple, List, Optional

class PiroLinearAlgebra:
    """Complete Linear Algebra Implementation for AI / AI iÃ§in Tam Lineer Cebir Implementasyonu"""
    
    def __init__(self, data: Union[List, np.ndarray], name: str = "Matrix"):
        """
        Initialize matrix / Matrisi baÅŸlat
        
        Args:
            data: Matrix data / Matris verisi
            name: Matrix name / Matris adÄ±
        """
        self.data = np.array(data, dtype=np.float64)
        self.name = name
        self._validate_matrix()
    
    def _validate_matrix(self):
        """Validate matrix dimensions / Matris boyutlarÄ±nÄ± doÄŸrula"""
        if self.data.ndim != 2:
            raise ValueError(f"âŒ {self.name}: Matrix must be 2D / Matris 2 boyutlu olmalÄ±!")
    
    # ğŸ”· 1. VEKTÃ–R OPERASYONLARI / VECTOR OPERATIONS
    @staticmethod
    def vector_operations_demo():
        """Demonstrate vector operations / VektÃ¶r operasyonlarÄ±nÄ± gÃ¶ster"""
        print("=== ğŸ”· VEKTÃ–R OPERASYONLARI / VECTOR OPERATIONS ===")
        
        # Vector creation / VektÃ¶r oluÅŸturma
        v = np.array([1, 2, 3])
        w = np.array([4, 5, 6])
        
        # Vector addition / VektÃ¶r toplama
        sum_vec = v + w
        print(f"Toplama / Addition: {v} + {w} = {sum_vec}")
        
        # Dot product / Nokta Ã§arpÄ±m
        dot_product = np.dot(v, w)
        print(f"Nokta Ã§arpÄ±m / Dot product: {v} Â· {w} = {dot_product}")
        
        # Cross product (3D only) / Ã‡apraz Ã§arpÄ±m (sadece 3D)
        if len(v) == 3 and len(w) == 3:
            cross_product = np.cross(v, w)
            print(f"Ã‡apraz Ã§arpÄ±m / Cross product: {v} Ã— {w} = {cross_product}")
        
        # Vector magnitude / VektÃ¶r bÃ¼yÃ¼klÃ¼ÄŸÃ¼
        magnitude = np.linalg.norm(v)
        print(f"BÃ¼yÃ¼klÃ¼k / Magnitude ||v|| = {magnitude:.2f}")
        
        # Unit vector / Birim vektÃ¶r
        unit_vector = v / magnitude
        print(f"Birim vektÃ¶r / Unit vector: {unit_vector}")
    
    # ğŸ”· 2. MATRÄ°S TEMEL OPERASYONLARI / MATRIX BASIC OPERATIONS
    def __str__(self) -> str:
        return f"ğŸ§® {self.name} {self.data.shape}:\n{self.data}"
    
    def __add__(self, other: 'PiroLinearAlgebra') -> 'PiroLinearAlgebra':
        """
        Matrix addition / Matris toplama
        A + B where A and B have same dimensions / A ve B aynÄ± boyutta olmalÄ±
        """
        if self.data.shape != other.data.shape:
            raise ValueError("âŒ Boyut uyumsuz / Dimension mismatch!")
        return PiroLinearAlgebra(self.data + other.data, f"({self.name}+{other.name})")
    
    def __sub__(self, other: 'PiroLinearAlgebra') -> 'PiroLinearAlgebra':
        """Matrix subtraction / Matris Ã§Ä±karma"""
        if self.data.shape != other.data.shape:
            raise ValueError("âŒ Boyut uyumsuz / Dimension mismatch!")
        return PiroLinearAlgebra(self.data - other.data, f"({self.name}-{other.name})")
    
    def __matmul__(self, other: 'PiroLinearAlgebra') -> 'PiroLinearAlgebra':
        """
        Matrix multiplication / Matris Ã§arpÄ±mÄ±
        A @ B where A.columns = B.rows / A sÃ¼tun = B satÄ±r sayÄ±sÄ±
        """
        if self.data.shape[1] != other.data.shape[0]:
            raise ValueError(f"âŒ Ã‡arpÄ±m iÃ§in uyumsuz boyutlar: {self.data.shape} @ {other.data.shape}")
        return PiroLinearAlgebra(self.data @ other.data, f"({self.name}@{other.name})")
    
    def __mul__(self, other: Union[int, float, 'PiroLinearAlgebra']) -> 'PiroLinearAlgebra':
        """
        Scalar multiplication or element-wise multiplication / 
        Skaler Ã§arpÄ±m veya eleman-elemana Ã§arpÄ±m
        """
        if isinstance(other, (int, float)):
            return PiroLinearAlgebra(self.data * other, f"({self.name}Ã—{other})")
        else:
            if self.data.shape != other.data.shape:
                raise ValueError("âŒ Boyut uyumsuz / Dimension mismatch!")
            return PiroLinearAlgebra(self.data * other.data, f"({self.name}âŠ™{other.name})")
    
    @property
    def T(self) -> 'PiroLinearAlgebra':
        """Matrix transpose / Matris transpozu"""
        return PiroLinearAlgebra(self.data.T, f"{self.name}áµ€")
    
    # ğŸ”· 3. DETERMINANT VE TERS / DETERMINANT AND INVERSE
    @property
    def determinant(self) -> float:
        """Calculate determinant / Determinant hesapla"""
        if not self.is_square:
            raise ValueError("âŒ Sadece kare matrislerin determinantÄ± var! / Only square matrices have determinant!")
        return np.linalg.det(self.data)
    
    @property
    def inverse(self) -> 'PiroLinearAlgebra':
        """Calculate matrix inverse / Matris tersini hesapla"""
        if not self.is_square:
            raise ValueError("âŒ Sadece kare matrislerin tersi var! / Only square matrices have inverse!")
        if abs(self.determinant) < 1e-10:
            raise ValueError("âŒ Matris singular - tersi yok! / Matrix is singular - no inverse!")
        return PiroLinearAlgebra(np.linalg.inv(self.data), f"{self.name}â»Â¹")
    
    @property
    def is_square(self) -> bool:
        """Check if matrix is square / Matris kare mi kontrol et"""
        return self.data.shape[0] == self.data.shape[1]
    
    # ğŸ”· 4. Ã–ZDEÄER VE Ã–ZVEKTÃ–RLER / EIGENVALUES AND EIGENVECTORS
    def eigen_decomposition(self) -> Tuple[np.ndarray, 'PiroLinearAlgebra']:
        """
        Eigen decomposition: A = V Î› Vâ»Â¹ / Ã–zdeÄŸer ayrÄ±ÅŸtÄ±rma
        Returns eigenvalues and eigenvectors / Ã–zdeÄŸerleri ve Ã¶zvektÃ¶rleri dÃ¶ndÃ¼rÃ¼r
        """
        if not self.is_square:
            raise ValueError("âŒ Sadece kare matrislerin Ã¶zdeÄŸeri var! / Only square matrices have eigenvalues!")
        
        eigenvalues, eigenvectors = np.linalg.eig(self.data)
        return eigenvalues, PiroLinearAlgebra(eigenvectors, f"eigvecs({self.name})")
    
    def verify_eigen_relation(self) -> bool:
        """Verify A Ã— v = Î» Ã— v relation / A Ã— v = Î» Ã— v iliÅŸkisini doÄŸrula"""
        try:
            eigenvalues, eigenvectors = self.eigen_decomposition()
            for i in range(len(eigenvalues)):
                v = eigenvectors.data[:, i]
                lambda_v = eigenvalues[i] * v
                Av = self.data @ v
                if not np.allclose(Av, lambda_v):
                    return False
            return True
        except:
            return False
    
    # ğŸ”· 5. TEKÄ°L DEÄER AYRIÅIMI (SVD) / SINGULAR VALUE DECOMPOSITION
    def svd(self) -> Tuple['PiroLinearAlgebra', np.ndarray, 'PiroLinearAlgebra']:
        """
        Singular Value Decomposition: A = U Î£ Váµ€ / Tekil DeÄŸer AyrÄ±ÅŸÄ±mÄ±
        Returns U, singular values, Váµ€ / U, tekil deÄŸerler, Váµ€ dÃ¶ndÃ¼rÃ¼r
        """
        U, S, Vt = np.linalg.svd(self.data, full_matrices=False)
        return (
            PiroLinearAlgebra(U, f"U_{self.name}"),
            S,
            PiroLinearAlgebra(Vt, f"Vt_{self.name}")
        )
    
    def low_rank_approximation(self, rank: int) -> 'PiroLinearAlgebra':
        """
        Low-rank approximation using SVD / SVD ile dÃ¼ÅŸÃ¼k ranklÄ± yaklaÅŸÄ±m
        Useful for data compression / Veri sÄ±kÄ±ÅŸtÄ±rma iÃ§in kullanÄ±ÅŸlÄ±
        """
        U, S, Vt = self.svd()
        U_k = U.data[:, :rank]
        S_k = np.diag(S[:rank])
        Vt_k = Vt.data[:rank, :]
        approximation = U_k @ S_k @ Vt_k
        return PiroLinearAlgebra(approximation, f"rank{rank}_approx({self.name})")
    
    # ğŸ”· 6. LÄ°NEER DENKLEM SÄ°STEMLERÄ° / LINEAR EQUATION SYSTEMS
    def solve(self, b: np.ndarray) -> 'PiroLinearAlgebra':
        """
        Solve linear system: A Ã— x = b / Lineer sistemi Ã§Ã¶z: A Ã— x = b
        Returns solution vector x / Ã‡Ã¶zÃ¼m vektÃ¶rÃ¼ x'i dÃ¶ndÃ¼rÃ¼r
        """
        if not self.is_square:
            raise ValueError("âŒ Sadece kare matris sistemleri Ã§Ã¶zÃ¼lebilir! / Only square systems can be solved!")
        
        x = np.linalg.solve(self.data, b)
        return PiroLinearAlgebra(x, f"solution({self.name})")
    
    def solve_least_squares(self, b: np.ndarray) -> 'PiroLinearAlgebra':
        """
        Solve overdetermined system using least squares / 
        AÅŸÄ±rÄ± belirlenmiÅŸ sistemi en kÃ¼Ã§Ã¼k kareler ile Ã§Ã¶z
        """
        x, residuals, rank, s = np.linalg.lstsq(self.data, b, rcond=None)
        return PiroLinearAlgebra(x, f"lstsq_solution({self.name})")
    
    # ğŸ”· 7. MATRÄ°S AYRIÅTIRMALARI / MATRIX DECOMPOSITIONS
    def lu_decomposition(self) -> Tuple['PiroLinearAlgebra', 'PiroLinearAlgebra', 'PiroLinearAlgebra']:
        """
        LU Decomposition: A = P L U / LU AyrÄ±ÅŸtÄ±rma
        Returns permutation matrix P, lower triangular L, upper triangular U /
        PermÃ¼tasyon matrisi P, alt Ã¼Ã§gensel L, Ã¼st Ã¼Ã§gensel U dÃ¶ndÃ¼rÃ¼r
        """
        P, L, U = scipy.linalg.lu(self.data)
        return (
            PiroLinearAlgebra(P, f"P_{self.name}"),
            PiroLinearAlgebra(L, f"L_{self.name}"),
            PiroLinearAlgebra(U, f"U_{self.name}")
        )
    
    def qr_decomposition(self) -> Tuple['PiroLinearAlgebra', 'PiroLinearAlgebra']:
        """
        QR Decomposition: A = Q R / QR AyrÄ±ÅŸtÄ±rma
        Returns orthogonal Q, upper triangular R / 
        Ortogonal Q, Ã¼st Ã¼Ã§gensel R dÃ¶ndÃ¼rÃ¼r
        """
        Q, R = np.linalg.qr(self.data)
        return PiroLinearAlgebra(Q, f"Q_{self.name}"), PiroLinearAlgebra(R, f"R_{self.name}")
    
    def cholesky_decomposition(self) -> 'PiroLinearAlgebra':
        """
        Cholesky Decomposition: A = L Láµ€ / Cholesky AyrÄ±ÅŸtÄ±rma
        For symmetric positive definite matrices / 
        Simetrik pozitif tanÄ±mlÄ± matrisler iÃ§in
        """
        try:
            L = np.linalg.cholesky(self.data)
            return PiroLinearAlgebra(L, f"L_chol_{self.name}")
        except np.linalg.LinAlgError:
            raise ValueError("âŒ Matris pozitif tanÄ±mlÄ± deÄŸil! / Matrix not positive definite!")
    
    # ğŸ”· 8. MATRÄ°S NORMLARI / MATRIX NORMS
    def norm(self, norm_type: str = 'fro') -> float:
        """
        Calculate matrix norms / Matris normlarÄ± hesapla
        
        Args:
            norm_type: 'fro' (Frobenius), 'spec' (Spectral), 'nuc' (Nuclear)
        """
        norms = {
            'fro': np.linalg.norm(self.data, 'fro'),    # Frobenius norm
            'spec': np.linalg.norm(self.data, 2),       # Spectral norm (largest singular value)
            'nuc': np.linalg.norm(self.data, 'nuc'),    # Nuclear norm (sum of singular values)
            '1': np.linalg.norm(self.data, 1),          # L1 norm (max column sum)
            'inf': np.linalg.norm(self.data, np.inf),   # Lâˆ norm (max row sum)
        }
        return norms.get(norm_type, norms['fro'])
    
    # ğŸ”· 9. VEKTÃ–R UZAYLARI / VECTOR SPACES
    def rank(self) -> int:
        """Matrix rank - number of linearly independent columns / Matris rankÄ± - lineer baÄŸÄ±msÄ±z sÃ¼tun sayÄ±sÄ±"""
        return np.linalg.matrix_rank(self.data)
    
    def null_space(self) -> 'PiroLinearAlgebra':
        """Null space - solutions to AÃ—x = 0 / Ã‡ekirdek - AÃ—x = 0 Ã§Ã¶zÃ¼mleri"""
        U, S, Vt = np.linalg.svd(self.data)
        tolerance = max(self.data.shape) * np.spacing(max(S))
        null_mask = S <= tolerance
        null_space = Vt[null_mask, :]
        return PiroLinearAlgebra(null_space.T, f"null({self.name})")
    
    def column_space(self) -> 'PiroLinearAlgebra':
        """Column space - all possible linear combinations of columns / SÃ¼tun uzayÄ± - sÃ¼tunlarÄ±n tÃ¼m lineer kombinasyonlarÄ±"""
        U, S, Vt = np.linalg.svd(self.data)
        tolerance = max(self.data.shape) * np.spacing(max(S))
        range_mask = S > tolerance
        column_space = U[:, range_mask]
        return PiroLinearAlgebra(column_space, f"col_space({self.name})")
    
    # ğŸ”· 10. Ä°LERÄ° UYGULAMALAR / ADVANCED APPLICATIONS
    def pca(self, n_components: int = 2) -> 'PiroLinearAlgebra':
        """
        Principal Component Analysis / Temel BileÅŸen Analizi
        Dimensionality reduction / Boyut indirgeme
        """
        # Standardize the data / Veriyi standardize et
        X_std = (self.data - np.mean(self.data, axis=0)) / np.std(self.data, axis=0)
        
        # Covariance matrix / Kovaryans matrisi
        cov_matrix = np.cov(X_std.T)
        
        # Eigen decomposition / Ã–zdeÄŸer ayrÄ±ÅŸtÄ±rma
        eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
        
        # Sort by largest eigenvalues / En bÃ¼yÃ¼k Ã¶zdeÄŸerlere gÃ¶re sÄ±rala
        sorted_indices = np.argsort(eigenvalues)[::-1]
        components = eigenvectors[:, sorted_indices[:n_components]]
        
        return PiroLinearAlgebra(components, f"PCA_{self.name}")
    
    def condition_number(self) -> float:
        """Condition number - measure of numerical stability / KoÅŸul sayÄ±sÄ± - sayÄ±sal kararlÄ±lÄ±k Ã¶lÃ§Ã¼tÃ¼"""
        return np.linalg.cond(self.data)
    
    def is_positive_definite(self) -> bool:
        """Check if matrix is positive definite / Matris pozitif tanÄ±mlÄ± mÄ± kontrol et"""
        try:
            np.linalg.cholesky(self.data)
            return True
        except np.linalg.LinAlgError:
            return False
    
    def is_symmetric(self) -> bool:
        """Check if matrix is symmetric / Matris simetrik mi kontrol et"""
        return np.allclose(self.data, self.data.T)
    
    def is_orthogonal(self) -> bool:
        """Check if matrix is orthogonal / Matris ortogonal mi kontrol et"""
        if not self.is_square:
            return False
        return np.allclose(self.data @ self.data.T, np.eye(self.data.shape[0]))

# ğŸ”¥ KOMPLE TEST FONKSÄ°YONU / COMPREHENSIVE TEST FUNCTION
def test_complete_linear_algebra():
    """Test all linear algebra features / TÃ¼m lineer cebir Ã¶zelliklerini test et"""
    print("=== ğŸ§ª TAM LÄ°NEER CEBÄ°R TESTÄ° / COMPLETE LINEAR ALGEBRA TEST ===")
    
    # 1. VektÃ¶r operasyonlarÄ± / Vector operations
    print("\n1. ğŸ”· VEKTÃ–R OPERASYONLARI / VECTOR OPERATIONS")
    PiroLinearAlgebra.vector_operations_demo()
    
    # 2. Test matrisleri oluÅŸtur / Create test matrices
    A = PiroLinearAlgebra([[4, 12, -16], [12, 37, -43], [-16, -43, 98]], "A")
    B = PiroLinearAlgebra([[1, 2], [3, 4], [5, 6]], "B")
    C = PiroLinearAlgebra([[2, 0], [0, 3]], "C")
    
    print(f"\n2. ğŸ”· MATRÄ°S TEMELLERÄ° / MATRIX BASICS")
    print(f"A: {A}")
    print(f"B: {B}")
    print(f"A boyutlarÄ± / dimensions: {A.data.shape}")
    print(f"B boyutlarÄ± / dimensions: {B.data.shape}")
    
    print(f"\n3. ğŸ”· MATRÄ°S OPERASYONLARI / MATRIX OPERATIONS")
    print(f"A + A: {(A + A).data.shape}")
    print(f"A Ã— B: {(A @ B).data.shape}")
    print(f"A transpozu / transpose: {A.T.data.shape}")
    
    print(f"\n4. ğŸ”· DETERMINANT VE TERS / DETERMINANT AND INVERSE")
    print(f"det(A): {A.determinant:.2f}")
    print(f"Aâ»Â¹: {A.inverse.data.shape}")
    print(f"A Ã— Aâ»Â¹ â‰ˆ I: {np.allclose((A @ A.inverse).data, np.eye(3))}")
    
    print(f"\n5. ğŸ”· Ã–ZDEÄER AYRIÅIMI / EIGEN DECOMPOSITION")
    eigenvalues, eigenvectors = A.eigen_decomposition()
    print(f"Ã–zdeÄŸerler / Eigenvalues: {eigenvalues}")
    print(f"Ã–zdeÄŸer iliÅŸkisi doÄŸru mu? / Eigen relation correct? {A.verify_eigen_relation()}")
    
    print(f"\n6. ğŸ”· SVD AYRIÅIMI / SVD DECOMPOSITION")
    U, S, Vt = A.svd()
    print(f"SVD: U{U.data.shape}, S{S.shape}, Vt{Vt.data.shape}")
    
    print(f"\n7. ğŸ”· LÄ°NEER SÄ°STEM Ã‡Ã–ZÃœMÃœ / LINEAR SYSTEM SOLUTION")
    b = np.array([1, 2, 3])
    x = A.solve(b)
    print(f"A Ã— x = b, x: {x.data}")
    print(f"DoÄŸrulama / Verification AÃ—x â‰ˆ b: {np.allclose(A.data @ x.data, b)}")
    
    print(f"\n8. ğŸ”· MATRÄ°S AYRIÅTIRMALARI / MATRIX DECOMPOSITIONS")
    L, U = A.lu_decomposition()[1:]  # Skip permutation matrix / PermÃ¼tasyon matrisini atla
    print(f"LU: L{L.data.shape}, U{U.data.shape}")
    
    Q, R = B.qr_decomposition()
    print(f"QR: Q{Q.data.shape}, R{R.data.shape}")
    
    print(f"\n9. ğŸ”· MATRÄ°S NORMLARI / MATRIX NORMS")
    print(f"Frobenius norm: {A.norm('fro'):.2f}")
    print(f"Spectral norm: {A.norm('spec'):.2f}")
    
    print(f"\n10. ğŸ”· VEKTÃ–R UZAYLARI / VECTOR SPACES")
    print(f"Rank(A): {A.rank()}")
    print(f"Null space boyutu / Null space dimension: {A.null_space().data.shape}")
    print(f"Column space boyutu / Column space dimension: {A.column_space().data.shape}")
    
    print(f"\n11. ğŸ”· Ä°LERÄ° UYGULAMALAR / ADVANCED APPLICATIONS")
    print(f"Pozitif tanÄ±mlÄ± mÄ±? / Positive definite? {A.is_positive_definite()}")
    print(f"Simetrik mi? / Symmetric? {A.is_symmetric()}")
    print(f"KoÅŸul sayÄ±sÄ± / Condition number: {A.condition_number():.2f}")
    
    # PCA test
    print(f"\n12. ğŸ”· PCA UYGULAMASI / PCA APPLICATION")
    random_data = np.random.randn(100, 5)  # 100 samples, 5 features / 100 Ã¶rnek, 5 Ã¶zellik
    X = PiroLinearAlgebra(random_data, "X")
    X_pca = X.pca(2)
    print(f"Orijinal veri / Original data: {X.data.shape}")
    print(f"PCA sonrasÄ± / After PCA: {X_pca.data.shape}")
    
    print(f"\nğŸ‰ TÃœM LÄ°NEER CEBÄ°R KONULARI TAMAMLANDI! / ALL LINEAR ALGEBRA TOPICS COMPLETED! ğŸ‰")

if __name__ == "__main__":
    test_complete_linear_algebra()